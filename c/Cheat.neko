GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')

class Scene_Cheat
	#GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
	def load_cheat
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_debug          = get_option.call('Debug'       ,     '0').to_i
		@c_exp            = get_option.call('Exp'         ,     '1').to_i
		@c_re             = get_option.call('Random_Event',     '0').to_i
		@c_text_speed     = get_option.call('Text_Speed'  ,     '0').to_i
		@c_bgm            = get_option.call('BGM'         ,     '0').to_i
		@c_bgs            = get_option.call('BGS'         ,     '0').to_i
		@c_me             = get_option.call('ME'          ,     '0').to_i
		@c_se             = get_option.call('SE'          ,     '0').to_i
	end
	
	def main
		@cheat_window = Window_Command.new(180,["Get Items", "Get Weapons", "Get Armors", "Edit Parameters", "Teleport", "Save", "Config"])
		@cheat_window.active = true
		@cheat_window.visible = true

		@parameters_window = Window_Command.new(120,["Gold", "Level", "MHP", "MMP", "ATK", "DEF", "MAT", "AGI"])
		@parameters_window.active = false
		@parameters_window.visible = false

		@gold_window = Window_Command.new(100,["+1K G", "5K G", "10K G", "50K G", "100K G", "500K G", "1M G", "5M G", "10M G"])
		@gold_window.active = false
		@gold_window.visible = false

		@level_window = Window_Command.new(100,["Lv 1", "Lv 10", "Lv 20", "Lv 30", "Lv 40", "Lv 50", "Lv 60", "Lv 70", "Lv 80", "Lv 90", "Lv 99", "Lv 999"])
		@level_window.active = false
		@level_window.visible = false
		
		parameters_opt = ["+500", "+1000", "+5000", "+10000", "+50000", "+100000", "-500", "-1000", "-5000", "-10000", "-50000", "-100000"]

		@mhp_window = Window_Command.new(120,parameters_opt)
		@mhp_window.active = false
		@mhp_window.visible = false

		@mmp_window = Window_Command.new(120,parameters_opt)
		@mmp_window.active = false
		@mmp_window.visible = false

		@atk_window = Window_Command.new(120,parameters_opt)
		@atk_window.active = false
		@atk_window.visible = false

		@def_window = Window_Command.new(120,parameters_opt)
		@def_window.active = false
		@def_window.visible = false

		@mat_window = Window_Command.new(120,parameters_opt)
		@mat_window.active = false
		@mat_window.visible = false

		@agi_window = Window_Command.new(120,parameters_opt)
		@agi_window.active = false
		@agi_window.visible = false

		@tp_window = Window_Command.new(160,["Save Pos 1", "Load Pos 1", "Save Pos 2", "Load Pos 2", "Save Pos 3", "Load Pos 3"])
		@tp_window.active = false
		@tp_window.visible = false

		@cfg_window = Window_Command.new(160,["Random Event", "Text Speed", "Debug Mode", "EXP drop rate", "BGM", "BGS", "ME", "SE", "Screen size", "Fullscreen"])
		@cfg_window.active = false
		@cfg_window.visible = false
		
		@c_re_window = Window_Command.new(160,["On (base)", "Off"])
		@c_re_window.active = false
		@c_re_window.visible = false
		
		@c_ts_window = Window_Command.new(160,["On", "Off (base)"])
		@c_ts_window.active = false
		@c_ts_window.visible = false
		
		@c_debug_window = Window_Command.new(160,["On", "Off (base)"])
		@c_debug_window.active = false
		@c_debug_window.visible = false
		
		@c_exp_window = Window_Command.new(160,["1x (base)", "5x", "10x", "15x", "20x", "25x"])
		@c_exp_window.active = false
		@c_exp_window.visible = false
		
		@volume_window = Window_Command.new(160,["0%", "10%", "20%", "30%", "40%", "50%", "60%", "70%", "80%", "90%", "100%", "Default"])
		@volume_window.active = false
		@volume_window.visible = false
		@volume_type = false

		@item_window = Window_GetItem.new
		@item_window.active = false
		@item_window.visible = false

		@number_window = Window_GetItemNumber.new(0,0)
		@number_window.active = false
		@number_window.visible = false

		Graphics.transition
		loop do
			Graphics.update
			Input.update
			update
			if $scene != self
				break
			end
		end
		Graphics.freeze
		@cheat_window.dispose
		@parameters_window.dispose
		@gold_window.dispose
		@level_window.dispose
		@mhp_window.dispose
		@mmp_window.dispose
		@atk_window.dispose
		@def_window.dispose
		@mat_window.dispose
		@agi_window.dispose
		@tp_window.dispose
		@cfg_window.dispose
		@c_ts_window.dispose
		@c_re_window.dispose
		@c_debug_window.dispose
		@c_exp_window.dispose
		@volume_window.dispose
		@item_window.dispose
		@number_window.dispose
		end

		def update
		@cheat_window.update
		@parameters_window.update
		@gold_window.update
		@level_window.update
		@mhp_window.update
		@mmp_window.update
		@atk_window.update
		@def_window.update
		@mat_window.update
		@agi_window.update
		@cfg_window.update
		@c_ts_window.update
		@c_re_window.update
		@c_debug_window.update
		@c_exp_window.update
		@volume_window.update
		@tp_window.update
		@item_window.update
		@number_window.update
		if @cheat_window.active
			update_cheat
			return
		end
		if @parameters_window.active
			update_parameters
			return
		end
		if @gold_window.active
			update_gold
			return
		end
		if @level_window.active
			update_level
			return
		end
		if @mhp_window.active
			update_mhp
			return
		end
		if @mmp_window.active
			update_mmp
			return
		end
		if @atk_window.active
			update_atk
			return
		end
		if @def_window.active
			update_def
			return
		end
		if @mat_window.active
			update_mat
			return
		end
		if @agi_window.active
			update_agi
			return
		end
		if @tp_window.active
			update_tp
			return
		end
		if @cfg_window.active
			update_cfg
			return
		end
		if @c_re_window.active
			update_c_re
			return
		end
		if @c_ts_window.active
			update_c_ts
			return
		end
		if @c_debug_window.active
			update_c_debug
			return
		end
		if @c_exp_window.active
			update_exp
			return
		end
		if @volume_window.active
			update_volume
			return
		end
		if @item_window.active
			update_item
			return
		end
		if @number_window.active
			update_number
			return
		end
	end

	def update_cheat
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @cheat_window.index
			when 0
				@cheat_window.active = false
				@cheat_window.visible = false
				@item_window.active = true
				@item_window.visible = true
				@item_window.set(0)
				@item_window.refresh
			when 1
				@cheat_window.active = false
				@cheat_window.visible = false
				@item_window.active = true
				@item_window.visible = true
				@item_window.set(1)
				@item_window.refresh
			when 2
				@cheat_window.active = false
				@cheat_window.visible = false
				@item_window.active = true
				@item_window.visible = true
				@item_window.set(2)
				@item_window.refresh
			when 3
				@cheat_window.active = false
				@cheat_window.visible = false
				@parameters_window.active = true
				@parameters_window.visible = true
				@parameters_window.refresh
			when 4
				@cheat_window.active = false
				@cheat_window.visible = false
				@tp_window.active = true
				@tp_window.visible = true
				@tp_window.refresh
			when 5
				$scene = Scene_File.new(true, false, false)
			when 6
				@cheat_window.active = false
				@cheat_window.visible = false
				@cfg_window.active = true
				@cfg_window.visible = true
				@cfg_window.refresh
			end
			return
		end
	end
	
	def update_parameters
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @parameters_window.index
			when 0
				@parameters_window.active = false
				@parameters_window.visible = false
				@gold_window.active = true
				@gold_window.visible = true
				@gold_window.refresh
			when 1
				@parameters_window.active = false
				@parameters_window.visible = false
				@level_window.active = true
				@level_window.visible = true
				@level_window.refresh
			when 2
				@parameters_window.active = false
				@parameters_window.visible = false
				@mhp_window.active = true
				@mhp_window.visible = true
				@mhp_window.refresh
			when 3
				@parameters_window.active = false
				@parameters_window.visible = false
				@mmp_window.active = true
				@mmp_window.visible = true
				@mmp_window.refresh
			when 4
				@parameters_window.active = false
				@parameters_window.visible = false
				@atk_window.active = true
				@atk_window.visible = true
				@atk_window.refresh
			when 5
				@parameters_window.active = false
				@parameters_window.visible = false
				@def_window.active = true
				@def_window.visible = true
				@def_window.refresh
			when 6
				@parameters_window.active = false
				@parameters_window.visible = false
				@mat_window.active = true
				@mat_window.visible = true
				@mat_window.refresh
			when 7
				@parameters_window.active = false
				@parameters_window.visible = false
				@agi_window.active = true
				@agi_window.visible = true
				@agi_window.refresh
			end
			return
		end
	end
	
	def update_cfg
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @cfg_window.index
			when 0
				@cfg_window.active = false
				@cfg_window.visible = false
				@c_re_window.active = true
				@c_re_window.visible = true
				@c_re_window.refresh
			when 1
				@cfg_window.active = false
				@cfg_window.visible = false
				@c_ts_window.active = true
				@c_ts_window.visible = true
				@c_ts_window.refresh
			when 2
				@cfg_window.active = false
				@cfg_window.visible = false
				@c_debug_window.active = true
				@c_debug_window.visible = true
				@c_debug_window.refresh
			when 3
				@cfg_window.active = false
				@cfg_window.visible = false
				@c_exp_window.active = true
				@c_exp_window.visible = true
				@c_exp_window.refresh
			when 4
				@cfg_window.active = false
				@cfg_window.visible = false
				@volume_type = 'BGM'
				@volume_window.active = true
				@volume_window.visible = true
				@volume_window.refresh
			when 5
				@cfg_window.active = false
				@cfg_window.visible = false
				@volume_type = 'BGS'
				@volume_window.active = true
				@volume_window.visible = true
				@volume_window.refresh
			when 6
				@cfg_window.active = false
				@cfg_window.visible = false
				@volume_type = 'ME'
				@volume_window.active = true
				@volume_window.visible = true
				@volume_window.refresh
			when 7
				@cfg_window.active = false
				@cfg_window.visible = false
				@volume_type = 'SE'
				@volume_window.active = true
				@volume_window.visible = true
				@volume_window.refresh
			when 8
				Graphics.toggle_ratio
				@cfg_window.active = true
				@cfg_window.visible = true
				@cfg_window.refresh
			when 9
				Graphics.toggle_fullscreen
				@cfg_window.active = true
				@cfg_window.visible = true
				@cfg_window.refresh
			end
			return
		end
	end
	
	def iterate_actor_id(param)
		if param == 0
			$game_party.members.each {|actor| yield actor }
		else
			actor = $game_actors[param]
			yield actor if actor
		end
	end
	
	def iterate_actor_var(param1, param2)
		if param1 == 0
			iterate_actor_id(param2) {|actor| yield actor }
		else
			iterate_actor_id($game_variables[param2]) {|actor| yield actor }
		end
	end

	def update_level
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @level_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(1, false)
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(10, false)
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(20, false)
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(30, false)
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(40, false)
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(50, false)
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(60, false)
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(70, false)
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(80, false)
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
					actor.change_level(90, false)
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.change_level(99, false)
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.change_level(999, false)
				end
				$scene = Scene_Map.new
			end
			return
		end
	end

	def update_gold
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @gold_window.index
			when 0
		$game_party.gain_gold(1000)
				$scene = Scene_Map.new
			when 1
				$game_party.gain_gold(5000)
				$scene = Scene_Map.new
			when 2
				$game_party.gain_gold(10000)
				$scene = Scene_Map.new
			when 3
				$game_party.gain_gold(50000)
				$scene = Scene_Map.new
			when 4
				$game_party.gain_gold(100000)
				$scene = Scene_Map.new
			when 5
				$game_party.gain_gold(500000)
				$scene = Scene_Map.new
			when 6
				$game_party.gain_gold(1000000)
				$scene = Scene_Map.new
			when 7
				$game_party.gain_gold(5000000)
				$scene = Scene_Map.new
			when 8
				$game_party.gain_gold(10000000)
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_mhp
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
				end
		if Input.trigger?(Input::C)
			case @mhp_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += 500
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += 1000
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += 5000
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += 10000
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += 50000
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += 100000
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += -500
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += -1000
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += -5000
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += -10000
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += -50000
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.maxhp += -100000
				end
				$scene = Scene_Map.new
				end
			return
		end
	end
	
	def update_mmp
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
				end
		if Input.trigger?(Input::C)
			case @mmp_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += 500
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += 1000
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += 5000
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += 10000
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += 50000
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += 100000
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += -500
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += -1000
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += -5000
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += -10000
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += -50000
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.maxmp += -100000
				end
				$scene = Scene_Map.new
				end
			return
		end
	end
	
	def update_atk
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @atk_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
				actor.atk += 500
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
				actor.atk += 1000
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
				actor.atk += 5000
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
				actor.atk += 10000
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
				actor.atk += 50000
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
				actor.atk += 100000
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
				actor.atk += -500
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
				actor.atk += -1000
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
				actor.atk += -5000
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
				actor.atk += -10000
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.atk += -50000
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.atk += -100000
				end
				$scene = Scene_Map.new
				end
			return
		end
	end
	
	def update_def
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @def_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
				actor.def += 500
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
				actor.def += 1000
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
				actor.def += 5000
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
				actor.def += 10000
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
				actor.def += 50000
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
				actor.def += 100000
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
				actor.def += -500
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
				actor.def += -1000
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
				actor.def += -5000
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
				actor.def += -10000
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.def += -50000
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.def += -100000
				end
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_mat
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @mat_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
				actor.spi += 500
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
				actor.spi += 1000
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
				actor.spi += 5000
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
				actor.spi += 10000
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
				actor.spi += 50000
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
				actor.spi += 100000
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
				actor.spi += -500
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
				actor.spi += -1000
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
				actor.spi += -5000
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
				actor.spi += -10000
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.spi += -50000
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.spi += -100000
				end
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_agi
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @agi_window.index
			when 0
				iterate_actor_var(0, 0) do |actor|
				actor.agi += 500
				end
				$scene = Scene_Map.new
			when 1
				iterate_actor_var(0, 0) do |actor|
				actor.agi += 1000
				end
				$scene = Scene_Map.new
			when 2
				iterate_actor_var(0, 0) do |actor|
				actor.agi += 5000
				end
				$scene = Scene_Map.new
			when 3
				iterate_actor_var(0, 0) do |actor|
				actor.agi += 10000
				end
				$scene = Scene_Map.new
			when 4
				iterate_actor_var(0, 0) do |actor|
				actor.agi += 50000
				end
				$scene = Scene_Map.new
			when 5
				iterate_actor_var(0, 0) do |actor|
				actor.agi += 100000
				end
				$scene = Scene_Map.new
			when 6
				iterate_actor_var(0, 0) do |actor|
				actor.agi += -500
				end
				$scene = Scene_Map.new
			when 7
				iterate_actor_var(0, 0) do |actor|
				actor.agi += -1000
				end
				$scene = Scene_Map.new
			when 8
				iterate_actor_var(0, 0) do |actor|
				actor.agi += -5000
				end
				$scene = Scene_Map.new
			when 9
				iterate_actor_var(0, 0) do |actor|
				actor.agi += -10000
				end
				$scene = Scene_Map.new
			when 10
				iterate_actor_var(0, 0) do |actor|
				actor.agi += -50000
				end
				$scene = Scene_Map.new
			when 11
				iterate_actor_var(0, 0) do |actor|
				actor.agi += -100000
				end
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_tp
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @tp_window.index
			when 0
				pos_1_file = "tele/pos_1.neko"
				File.open(pos_1_file, "w") { |f| f.write $game_map.map_id.to_s + ", " + $game_player.x.to_s + ", " + $game_player.y.to_s}
				$scene = Scene_Map.new
			when 1
				read_pos_1 = File.read("tele/pos_1.neko").split
				pos_1_map = read_pos_1[0]
				pos_1_x = read_pos_1[1]
				pos_1_y = read_pos_1[2]
				$game_player.reserve_transfer(pos_1_map.to_i, pos_1_x.to_i, pos_1_y.to_i, 0)
				$scene = Scene_Map.new
			when 2
				pos_2_file = "tele/pos_2.neko"
				File.open(pos_2_file, "w") { |f| f.write $game_map.map_id.to_s + ", " + $game_player.x.to_s + ", " + $game_player.y.to_s}
				$scene = Scene_Map.new
			when 3
				read_pos_2 = File.read("tele/pos_2.neko").split
				pos_2_map = read_pos_2[0]
				pos_2_x = read_pos_2[1]
				pos_2_y = read_pos_2[2]
				$game_player.reserve_transfer(pos_2_map.to_i, pos_2_x.to_i, pos_2_y.to_i, 0)
				$scene = Scene_Map.new
			when 4
				pos_3_file = "tele/pos_3.neko"
				File.open(pos_3_file, "w") { |f| f.write $game_map.map_id.to_s + ", " + $game_player.x.to_s + ", " + $game_player.y.to_s}
				$scene = Scene_Map.new
			when 5
				read_pos_3 = File.read("tele/pos_2.neko").split
				pos_3_map = read_pos_3[0]
				pos_3_x = read_pos_3[1]
				pos_3_y = read_pos_3[2]
				$game_player.reserve_transfer(pos_3_map.to_i, pos_3_x.to_i, pos_3_y.to_i, 0)
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_c_re
	save_location = './Game_Cheat.ini'
	section       = 'Cheat_cfg'
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @c_re_window.index
			when 0
				@c_re = 0
				WritePrivateProfileString.call(section, 'Random_Event', @c_re.to_s, save_location)
				$scene = Scene_Map.new
			when 1
				@c_re = 1
				WritePrivateProfileString.call(section, 'Random_Event', @c_re.to_s, save_location)
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_c_ts
	save_location = './Game_Cheat.ini'
	section       = 'Cheat_cfg'
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @c_ts_window.index
			when 0
				@c_ts = 0
				WritePrivateProfileString.call(section, 'Text_Speed', @c_ts.to_s, save_location)
				$scene = Scene_Map.new
			when 1
				@c_ts = 1
				WritePrivateProfileString.call(section, 'Text_Speed', @c_ts.to_s, save_location)
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_c_debug
	save_location = './Game_Cheat.ini'
	section       = 'Cheat_cfg'
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @c_debug_window.index
			when 0
				@c_debug = 1
				WritePrivateProfileString.call(section, 'Debug', @c_debug.to_s, save_location)
				$scene = Scene_Map.new
			when 1
				@c_debug = 0
				WritePrivateProfileString.call(section, 'Debug', @c_debug.to_s, save_location)
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_exp
	save_location = './Game_Cheat.ini'
	section       = 'Cheat_cfg'
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @c_exp_window.index
			when 0
				@c_exp = 1
				WritePrivateProfileString.call(section, 'Exp', @c_exp.to_s, save_location)
				$scene = Scene_Map.new
			when 1
				@c_exp = 5
				WritePrivateProfileString.call(section, 'Exp', @c_exp.to_s, save_location)
				$scene = Scene_Map.new
			when 2
				@c_exp = 10
				WritePrivateProfileString.call(section, 'Exp', @c_exp.to_s, save_location)
				$scene = Scene_Map.new
			when 3
				@c_exp = 15
				WritePrivateProfileString.call(section, 'Exp', @c_exp.to_s, save_location)
				$scene = Scene_Map.new
			when 4
				@c_exp = 20
				WritePrivateProfileString.call(section, 'Exp', @c_exp.to_s, save_location)
				$scene = Scene_Map.new
			when 5
				@c_exp = 25
				WritePrivateProfileString.call(section, 'Exp', @c_exp.to_s, save_location)
				$scene = Scene_Map.new
			end
			return
		end
	end
	
	def update_volume
	save_location = './Game_Cheat.ini'
	section       = 'Cheat_cfg'
	if @volume_type == false
		print("volume_type not defined")
		$scene = Scene_Map.new
	end
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			case @volume_window.index
			when 0
				@volume_value = 0
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 1
				@volume_value = 10
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 2
				@volume_value = 20
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 3
				@volume_value = 30
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 4
				@volume_value = 40
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 5
				@volume_value = 50
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 6
				@volume_value = 60
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 7
				@volume_value = 70
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 8
				@volume_value = 80
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 9
				@volume_value = 90
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 10
				@volume_value = 100
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			when 11
				@volume_value = -1
				WritePrivateProfileString.call(section, @volume_type, @volume_value.to_s, save_location)
				@volume_type = false
				$game_temp.map_bgm = RPG::BGM.last
				$game_temp.map_bgs = RPG::BGS.last
				RPG::BGM.stop
                RPG::BGS.stop
				$scene = Scene_Map.new
				$game_temp.map_bgm.play
				$game_temp.map_bgs.play
			end
			return
		end
	end

	def update_item
		if Input.trigger?(Input::B)
			$scene = Scene_Map.new
			return
		end
		if Input.trigger?(Input::C)
			@item = @item_window.item
			if @item == nil
				return
			end
			number = $game_party.item_number(@item)
			max = 99
			max = [max, 99 - number].min
			@item_window.active = false
			@item_window.visible = false
			@number_window.set(@item, max, @item.price)
			@number_window.active = true
			@number_window.visible = true
		end
	end

	def update_number
		if Input.trigger?(Input::B)
			@number_window.active = false
			@number_window.visible = false
			@item_window.active = true
			@item_window.visible = true
			return
		end
		if Input.trigger?(Input::C)
			@number_window.active = false
			@number_window.visible = false
			$game_party.gain_item(@item, @number_window.number)
			
			@item_window.refresh
			@item_window.active = true
			@item_window.visible = true
			return
		end
	end
end

class Window_GetItemNumber < Window_Base
	def initialize(x, y)
		super(x, y, 304, 120)
		@item = nil
		@max = 1
		@price = 0
		@number = 1
	end
	def set(item, max, price)
		@item = item
		@max = max
		@price = 0
		@number = 1
		refresh
	end
	def number
		return @number
	end
	def refresh
		y = 0
		self.contents.clear
		draw_item_name(@item, 0, y)
		self.contents.font.color = normal_color
		self.contents.draw_text(212, y, 20, WLH, "Ã—")
		self.contents.draw_text(248, y, 20, WLH, @number, 2)
		self.cursor_rect.set(244, y, 28, WLH)
		draw_currency_value(@price * @number, 4, y + WLH * 2, 264)
	end
	def update
		super
		if self.active
			last_number = @number
			if Input.repeat?(Input::RIGHT) and @number < @max
				@number += 1
			end
			if Input.repeat?(Input::LEFT) and @number > 1
				@number -= 1
			end
			if Input.repeat?(Input::UP) and @number < @max
				@number = [@number + 10, @max].min
			end
			if Input.repeat?(Input::DOWN) and @number > 1
				@number = [@number - 10, 1].max
			end
			if @number != last_number
				Sound.play_cursor
				refresh
			end
		end
	end
end

class Window_GetItem < Window_Selectable
	def initialize
		super(0, 0, 280, 304)
		@shop_goods = []
		@shop_goods += $data_items
		@shop_goods += $data_weapons
		@shop_goods += $data_armors
		refresh
		self.index = 0
	end
	def set(type)
		if type == 0
			@shop_goods -= $data_weapons
			@shop_goods -= $data_armors
		end
		if type == 1
			@shop_goods -= $data_items
			@shop_goods -= $data_armors
		end
		if type == 2
			@shop_goods -= $data_items
			@shop_goods -= $data_weapons
		end
	end
	def item
		return @data[self.index]
		end
	def refresh
		if self.contents != nil
			self.contents.dispose
			self.contents = nil
		end
		@data = []
		for item in @shop_goods
			if item != nil && item.name != ""
				@data.push(item)
			end
		end
		@item_max = @data.size
		if @item_max > 0
			self.contents = Bitmap.new(width - 32, row_max * 32)
			for i in 0...@item_max
				draw_item(i)
			end
		end
	end
	def draw_item(index)
		item = @data[index]
		self.contents.font.color = normal_color
		
		x = 4
		y = index * WLH
		rect = Rect.new(x, y, self.width - 32, WLH)
		self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
		opacity = self.contents.font.color == normal_color ? 255 : 128
		self.contents.draw_text(x + 4, y, 212, WLH, item.name, 0)
		self.contents.draw_text(x + 220, y, 88,WLH, item.price.to_s, 2)
	end
end

class Game_Player < Game_Character
	def update_encounter
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_re   = get_option.call('Random_Event', '0').to_i
		
		if @c_re == 1
			return
		end
	end
end

class Window_Message < Window_Selectable
	alias neko_text_speed start_choice
	def start_choice
		buffer = [].pack('x256')
			save_location = './Game_Cheat.ini'
			section       = 'Cheat_cfg'
			
			get_option = Proc.new do |key, default_value|
				l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
				buffer[0, l]
			end
			@c_text_speed   = get_option.call('Text_Speed', '0').to_i
			
		if @c_text_speed == 1
			@show_fast = true
		end
		self.active = true
		self.index = 0
		neko_text_speed
	end
end

class Game_Troop < Game_Unit
	def exp_total
		exp = 0
		for enemy in dead_members
			exp += enemy.exp unless enemy.hidden
		end
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_exp   = get_option.call('Exp', '0').to_i
		@c_debug = get_option.call('Debug', '0').to_i
		
		if @c_exp == 0
			return exp * 1
		else
			return exp * @c_exp
		end
	end
end

class RPG::BGM < RPG::AudioFile
	alias neko_play play
	def play
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_bgm   = get_option.call('BGM', '0').to_i
		
		if @c_bgm != -1
			@volume = @c_bgm
		end
		neko_play
	end
end
class RPG::BGS < RPG::AudioFile
	alias neko_play play
	def play
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_bgs   = get_option.call('BGS', '0').to_i
		
		if @c_bgs != -1
			@volume = @c_bgs
		end
		neko_play
	end
end
class RPG::ME < RPG::AudioFile
	alias neko_play play
	def play
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_me   = get_option.call('ME', '0').to_i
		
		if @c_me != -1
			@volume = @c_me
		end
		neko_play
	end
end
class RPG::SE < RPG::AudioFile
	alias neko_play play
	def play
		buffer = [].pack('x256')
		save_location = './Game_Cheat.ini'
		section       = 'Cheat_cfg'
		
		get_option = Proc.new do |key, default_value|
			l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
			buffer[0, l]
		end
		@c_se   = get_option.call('SE', '0').to_i
		
		if @c_se != -1
			@volume = @c_se
		end
		neko_play
	end
end

# Fullscreen++ v2.2 for VX and VXace by Zeus81
# Free for non commercial and commercial use
# Licence : http://creativecommons.org/licenses/by-sa/3.0/
# Contact : zeusex81@gmail.com
# (fr) Manuel d'utilisation : http://pastebin.com/raw.php?i=1TQfMnVJ
# (en) User Guide           : http://pastebin.com/raw.php?i=EgnWt9ur
 
$imported ||= {}
$imported[:Zeus_Fullscreen] = __FILE__

class << Graphics
  Disable_VX_Fullscreen = false
 
  CreateWindowEx            = Win32API.new('user32'  , 'CreateWindowEx'           , 'ippiiiiiiiii', 'i')
  GetClientRect             = Win32API.new('user32'  , 'GetClientRect'            , 'ip'          , 'i')
  GetDC                     = Win32API.new('user32'  , 'GetDC'                    , 'i'           , 'i')
  GetSystemMetrics          = Win32API.new('user32'  , 'GetSystemMetrics'         , 'i'           , 'i')
  GetWindowRect             = Win32API.new('user32'  , 'GetWindowRect'            , 'ip'          , 'i')
  FillRect                  = Win32API.new('user32'  , 'FillRect'                 , 'ipi'         , 'i')
  FindWindow                = Win32API.new('user32'  , 'FindWindow'               , 'pp'          , 'i')
  ReleaseDC                 = Win32API.new('user32'  , 'ReleaseDC'                , 'ii'          , 'i')
  SendInput                 = Win32API.new('user32'  , 'SendInput'                , 'ipi'         , 'i')
  SetWindowLong             = Win32API.new('user32'  , 'SetWindowLong'            , 'iii'         , 'i')
  SetWindowPos              = Win32API.new('user32'  , 'SetWindowPos'             , 'iiiiiii'     , 'i')
  ShowWindow                = Win32API.new('user32'  , 'ShowWindow'               , 'ii'          , 'i')
  SystemParametersInfo      = Win32API.new('user32'  , 'SystemParametersInfo'     , 'iipi'        , 'i')
  UpdateWindow              = Win32API.new('user32'  , 'UpdateWindow'             , 'i'           , 'i')
  GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
  WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')
  CreateSolidBrush          = Win32API.new('gdi32'   , 'CreateSolidBrush'         , 'i'           , 'i')
  DeleteObject              = Win32API.new('gdi32'   , 'DeleteObject'             , 'i'           , 'i')
 
  unless method_defined?(:zeus_fullscreen_update)
    HWND     = FindWindow.call('RGSS Player', 0)
    BackHWND = CreateWindowEx.call(0x08000008, 'Static', '', 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0)
    alias zeus_fullscreen_resize_screen resize_screen
    alias zeus_fullscreen_update        update
  end
private
  def initialize_fullscreen_rects
    @borders_size    ||= borders_size
    @fullscreen_rect ||= screen_rect
    @workarea_rect   ||= workarea_rect
  end
  def borders_size
    GetWindowRect.call(HWND, wrect = [0, 0, 0, 0].pack('l4'))
    GetClientRect.call(HWND, crect = [0, 0, 0, 0].pack('l4'))
    wrect, crect = wrect.unpack('l4'), crect.unpack('l4')
    Rect.new(0, 0, wrect[2]-wrect[0]-crect[2], wrect[3]-wrect[1]-crect[3])
  end
  def screen_rect
    Rect.new(0, 0, GetSystemMetrics.call(0), GetSystemMetrics.call(1))
  end
  def workarea_rect
    SystemParametersInfo.call(0x30, 0, rect = [0, 0, 0, 0].pack('l4'), 0)
    rect = rect.unpack('l4')
    Rect.new(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
  end
  def hide_borders() SetWindowLong.call(HWND, -16, 0x14000000) end
  def show_borders() SetWindowLong.call(HWND, -16, 0x14CA0000) end
  def hide_back()    ShowWindow.call(BackHWND, 0)              end
  def show_back
    ShowWindow.call(BackHWND, 3)
    UpdateWindow.call(BackHWND)
    dc    = GetDC.call(BackHWND)
    rect  = [0, 0, @fullscreen_rect.width, @fullscreen_rect.height].pack('l4')
    brush = CreateSolidBrush.call(0)
    FillRect.call(dc, rect, brush)
    ReleaseDC.call(BackHWND, dc)
    DeleteObject.call(brush)
  end
  def resize_window(w, h)
    if @fullscreen
      x, y, z = (@fullscreen_rect.width-w)/2, (@fullscreen_rect.height-h)/2, -1
    else
      w += @borders_size.width
      h += @borders_size.height
      x = @workarea_rect.x + (@workarea_rect.width  - w) / 2
      y = @workarea_rect.y + (@workarea_rect.height - h) / 2
      z = -2
    end
    SetWindowPos.call(HWND, z, x, y, w, h, 0)
  end
  def release_alt
    inputs = [1,18,2, 1,164,2, 1,165,2].pack('LSx2Lx16'*3)
    SendInput.call(3, inputs, 28)
  end
public
  def load_fullscreen_settings
    buffer = [].pack('x256')
    section = 'Fullscreen++'
    filename = './Game_Cheat.ini'
    get_option = Proc.new do |key, default_value|
      l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, filename)
      buffer[0, l]
    end
    @fullscreen       = get_option.call('Fullscreen'     , '0') == '1'
    @fullscreen_ratio = get_option.call('FullscreenRatio', '0').to_i
    @windowed_ratio   = get_option.call('WindowedRatio'  , '1').to_i
    toggle_vx_fullscreen if Disable_VX_Fullscreen and vx_fullscreen?
    fullscreen? ? fullscreen_mode : windowed_mode
  end
  def save_fullscreen_settings
    section = 'Fullscreen++'
    filename = './Game_Cheat.ini'
    set_option = Proc.new do |key, value|
      WritePrivateProfileString.call(section, key, value.to_s, filename)
    end
    set_option.call('Fullscreen'     , @fullscreen ? '1' : '0')
    set_option.call('FullscreenRatio', @fullscreen_ratio)
    set_option.call('WindowedRatio'  , @windowed_ratio)
  end
  def fullscreen?
    @fullscreen or vx_fullscreen?
  end
  def vx_fullscreen?
    rect = screen_rect
    rect.width == 640 and rect.height == 480
  end
  def toggle_fullscreen
    fullscreen? ? windowed_mode : fullscreen_mode
  end
  def toggle_vx_fullscreen
    windowed_mode if @fullscreen and !vx_fullscreen?
    inputs = [1,18,0, 1,13,0, 1,13,2, 1,18,2].pack('LSx2Lx16'*4)
    SendInput.call(4, inputs, 28)
    zeus_fullscreen_update
    self.ratio += 0 # refresh window size
  end
  def vx_fullscreen_mode
    return if vx_fullscreen?
    toggle_vx_fullscreen
  end
  def fullscreen_mode
    return if vx_fullscreen?
    initialize_fullscreen_rects
    show_back
    hide_borders
    @fullscreen = true
    self.ratio += 0 # refresh window size
  end
  def windowed_mode
    toggle_vx_fullscreen if vx_fullscreen?
    initialize_fullscreen_rects
    hide_back
    show_borders
    @fullscreen = false
    self.ratio += 0 # refresh window size
  end
  def toggle_ratio
    return if vx_fullscreen?
    self.ratio += 1
  end
  def ratio
    return 1 if vx_fullscreen?
    @fullscreen ? @fullscreen_ratio : @windowed_ratio
  end
  def ratio=(r)
    return if vx_fullscreen?
    initialize_fullscreen_rects
    r = 0 if r < 0
    if @fullscreen
      @fullscreen_ratio = r
      w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
    else
      @windowed_ratio = r
      w_max = @workarea_rect.width  - @borders_size.width
      h_max = @workarea_rect.height - @borders_size.height
    end
    if r == 0
      w, h = w_max, w_max * height / width
      h, w = h_max, h_max * width / height if h > h_max
    else
      w, h = width * r, height * r
      return self.ratio = 0 if w > w_max or h > h_max
    end
    resize_window(w, h)
    save_fullscreen_settings
  end
  def update
    release_alt if Disable_VX_Fullscreen and Input.trigger?(Input::ALT)
    zeus_fullscreen_update
    toggle_fullscreen if Input.trigger?(Input::F5)
    toggle_ratio      if Input.trigger?(Input::F6)
  end
  def resize_screen(width, height)
    zeus_fullscreen_resize_screen(width, height)
    self.ratio += 0 # refresh window size
  end
end
Graphics.load_fullscreen_settings
	
class Game_Player
	alias :cheat_update :update
	def update
		cheat_update
		
			buffer = [].pack('x256')
			save_location = './Game_Cheat.ini'
			section       = 'Cheat_cfg'
			
			get_option = Proc.new do |key, default_value|
				l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
				buffer[0, l]
			end
			@c_debug          = get_option.call('Debug'       ,     '0').to_i
			@c_exp            = get_option.call('Exp'         ,     '1').to_i
			@c_re             = get_option.call('Random_Event',     '0').to_i
			@c_text_speed     = get_option.call('Text_Speed'  ,     '0').to_i
			@c_bgm            = get_option.call('BGM'         ,     '-1').to_i
			@c_bgs            = get_option.call('BGS'         ,     '-1').to_i
			@c_me             = get_option.call('ME'          ,     '-1').to_i
			@c_se             = get_option.call('SE'          ,     '-1').to_i
			
		if Input.press?(Input::F8)
			$scene = Scene_Cheat.new
		end
		if Input.press?(Input::F9) && @c_debug == 1 && !$game_player.moving? && !$TEST
			$scene = Scene_Debug.new
		end
		
		def debug_through?
			buffer = [].pack('x256')
			save_location = './Game_Cheat.ini'
			section       = 'Cheat_cfg'
			
			get_option = Proc.new do |key, default_value|
				l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, save_location)
				buffer[0, l]
			end
			@c_debug = get_option.call('Debug',  '0').to_i
			@c_exp   = get_option.call('Exp',    '0').to_i
			
			if Input.press?(Input::CTRL) && @c_debug == 1
				return true
			end
			if $TEST && Input.press?(:CTRL)
				return true 
			end
			return false
		end
	end
end